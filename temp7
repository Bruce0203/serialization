    fn run(
        mut src: &S,
        codec: &mut C,
        _skip_acc: usize,
        vectored_amount: usize,
    ) -> Result<(), C::Error> {
        let skip_acc = 0;
        src = unsafe { &*(src as *const S).byte_sub(1) };
        {
            let mut src = src;
            let vec = unsafe { transmute::<_, &T>(src) };
            for _ in 0..vectored_amount {
                <<<T as Vector>::Item as Mesh<C>>::Output as EncodeActor<
                    <T as Vector>::Item,
                    C,
                >>::run(
                    unsafe { transmute(vec.as_ptr()) },
                    codec,
                    skip_acc,
                    vec.len(),
                )?;
                src = unsafe { &*(src as *const S).byte_add(<S as Size>::SIZE) };
            }
        }
        src = unsafe { &*(src as *const S).byte_add(<T as Size>::SIZE) };
        B::run(src, codec, skip_acc, vectored_amount)
    }

